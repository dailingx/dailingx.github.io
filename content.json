{"meta":{"title":"dailingx","subtitle":"DaiXinliang's Blog","description":"Ò»¸öÉXÉmµÄ²©¿Í£¬Éñ ÄÎðÅç","author":"dailingx","url":"http://yoursite.com"},"pages":[{"title":"分类","date":"2018-12-11T16:00:00.000Z","updated":"2018-12-12T11:23:14.239Z","comments":true,"path":"categories/page.html","permalink":"http://yoursite.com/categories/page.html","excerpt":"","text":""},{"title":"Tagcloud","date":"2018-12-11T16:00:00.000Z","updated":"2018-12-12T11:36:24.576Z","comments":true,"path":"tags/tags.html","permalink":"http://yoursite.com/tags/tags.html","excerpt":"","text":""}],"posts":[{"title":"hiho一下   第232周","slug":"hihoCoder  Week232 question01","date":"2018-12-17T01:16:29.325Z","updated":"2018-12-17T10:45:09.628Z","comments":true,"path":"2018/12/17/hihoCoder  Week232 question01/","link":"","permalink":"http://yoursite.com/2018/12/17/hihoCoder  Week232 question01/","excerpt":"","text":"题目1：拆字游戏时间限制:10000ms单点时限:1000ms内存限制:256MB 描述小Kui喜欢把别人的名字拆开来，比如“螺”就可以拆成“虫田糸”，小Kui的语文学的不是很好，于是她决定使用编程的方式来解决这个问题。给出一个01矩阵，1占据的部分即为需要拆的字，如果两个1分享一条边，那么它们连通。连通具有传递性，即如果a、b连通，b、c连通，则a、c连通。连通的一系列1被看做可以拆出的一块，现在小Kui需要输出这些拆出的块（用一个01矩阵表示，并且要求矩阵的大小尽可能的小）。为了确保输出的顺序尽可能的和书写的顺序一致，小Kui从每个块中选出最左上角的点（最左侧的点中，最靠上的）作为代表点，然后按照代表点从左到右（若相同则按从上到下）的顺序输出所有拆出的块。 输入输入的第一行为两个正整数N、M，表示01矩阵的大小。 接下来N行，每行M个01字符，描述一个需要拆的字。 对于40%的数据，满足1&lt;=N,M&lt;=10。 对于100%的数据，满足1&lt;=N,M&lt;=500。 输出按照代表点从左到右（若相同则按从上到下）的顺序输出所有拆出的块。 对于每个块，先输出其大小，然后用对应的01矩阵表示这个块。 样例 样例输入 样例输出 11 170000000000000000000001111111100000000000000000000000011111111111110000000000100000000000000101011100000000011010001100000011100100001000000000101000000000000000110000000000000000000000000 7 1311111111111110000001000000000000100000000000010000000000001000000000000100000000000110000003 40001001111101 8111111111 113 4111000110001 额外的样例 样例输入 样例输出 14 2200000000000011111111000000000000001101101100000011000000111111110000001100000011011011000111111110001111111100011011011000000000000001101101100000110000000111111110001111111000000011000000000110000000001101100011111111000111111111000111111000000000001000110110110000000000000000011000000000000000000011100000 10 90001100000001100001111111101101101101101101101111111100001100000001101101111111110000000105 811111111110110111111111111011011111111118 80011000011111110000110001111111101111110110110110001100000111000 思路赛时，一看到题目就觉得要逐点并查集合并一下，然后再将每个合并块输出，但实现起来还是颇为麻烦的。后来想想，自己还是想复杂了，直接逐点深搜或者广搜都行，注意要边搜边将已经搜过的块打好标记就是。C++选手刚转型Java选手，上来就拿Java试手，交了一发Java版dfs，结果TLE。没道理啊，考虑到bfs可能会快一点，于是转一手Java版bfs，还是TLE。看了好几遍，思路代码都没问题的呀，百思不得其解，莫非是Java语言本身运行的慢而题目却没有给Java增加额外的耗时，于是将我打回C++原形，写了两发C++的dfs和bfs，结果全都是TLE只过百分之40的数据。后来后来。。。才发现，C++里是我在双重循环里memset整个505505的数组而造成极大的开销(Java里则是在双重循环里面new出505505的数组)，改成预先定义好最大数组然后每次手动for循环重置数组就AC了。。。。 我的方法是把每次搜到的结果放到res数组里，并且在搜索时，每搜到一个点都需要判断当前点与sx,sy,px,py的大小，从而获得搜索路径的左上角坐标和左下角坐标进而得到搜到块的大小。 原来memset要慎用！！！直接对最大数组memset(尤其是如果在循环里面需要多次重置!)，还不如手动对已知数组范围进行重置清零！！！从此再也不敢用memset偷懒了(逃 我的代码Java&nbsp;&nbsp;&nbsp;&nbsp;dfs/bfs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152import java.io.BufferedInputStream;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.PrintWriter;import java.math.BigInteger;import java.util.StringTokenizer;public class Main &#123; public static InputReader in = new InputReader(new BufferedInputStream(System.in)); public static PrintWriter out = new PrintWriter(System.out); public static char[][] Map; public static int[][] res = new int[505][505]; public static int[][] vis = new int[505][505]; public static int sx, sy, px, py; public static int dx[] = &#123;1, 0, -1, 0&#125;; public static int dy[] = &#123;0, 1, 0, -1&#125;; public static int n, m; public static void main(String[] args) &#123; String s; Map = new char[505][505]; n = in.nextInt(); m = in.nextInt(); for (int i = 1; i &lt;= n; i++) &#123; s = in.nextLine(); for (int j = 1; j &lt;= m; j++) &#123; Map[i][j] = s.charAt(j - 1); &#125; &#125; for (int j = 1; j &lt;= m; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; if (Map[i][j] == '1') &#123; px = i; py = j; sx = i; sy = j; vis[i][j] = '2'; res[i][j] = 1; dfs(i, j); out.println((px - sx + 1) + \" \" + (py - sy + 1)); out.flush(); for (int k = sx; k &lt;= px; k++) &#123; for (int p = sy; p &lt;= py; p++) &#123; out.print(res[k][p]); out.flush(); if (res[k][p] != 0) res[k][p] = 0; if (vis[k][p] != 0) vis[k][p] = 0; &#125; out.println(); out.flush(); &#125; &#125; &#125; &#125; out.close(); &#125; static void dfs(int x, int y) &#123; for (int i = 0; i &lt; 4; i++) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= m &amp;&amp; vis[nx][ny] == 0 &amp;&amp; Map[nx][ny] == '1') &#123; vis[nx][ny] = 1; res[nx][ny] = 1; if (nx &gt; px) &#123; px = nx; &#125; if (ny &gt; py) &#123; py = ny; &#125; if (nx &lt; sx) &#123; sx = nx; &#125; if (ny &lt; sy) &#123; sy = ny; &#125; Map[nx][ny] = '2'; dfs(nx, ny); vis[nx][ny] = 0; &#125; &#125; &#125; static class Point &#123; int x, y; &#125; static void bfs(int x, int y) &#123; Queue&lt;Point&gt; queue = new LinkedList&lt;&gt;(); Point now = new Point(); now.x = x; now.y = y; queue.add(now); vis[x][y] = 1; while (!queue.isEmpty()) &#123; now = queue.poll(); out.flush(); for (int i = 0; i &lt; 4; i++) &#123; Point next = new Point(); next.x = now.x + dx[i]; next.y = now.y + dy[i]; if (next.x &gt; 0 &amp;&amp; next.x &lt;= n &amp;&amp; next.y &gt; 0 &amp;&amp; next.y &lt;= m &amp;&amp; vis[next.x][next.y] == 0 &amp;&amp; Map[next.x][next.y] == '1') &#123; vis[next.x][next.y] = 1; res[next.x][next.y] = 1; if (next.x &gt; px) &#123; px = next.x; &#125; if (next.y &gt; py) &#123; py = next.y; &#125; if (next.x &lt; sx) &#123; sx = next.x; &#125; if (next.y &lt; sy) &#123; sy = next.y; &#125; Map[next.x][next.y] = '2'; queue.add(next); &#125; &#125; &#125; &#125; static class InputReader &#123; public BufferedReader reader; public StringTokenizer tokenizer; public InputReader(InputStream stream) &#123; reader = new BufferedReader(new InputStreamReader(stream), 32768); tokenizer = null; &#125; public String nextLine() &#123; String str = null; try &#123; str = reader.readLine(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return str; &#125; public int nextInt() &#123; return Integer.parseInt(next()); &#125; &#125;&#125; C++&nbsp;&nbsp;&nbsp;&nbsp;dfs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;char Map[505][505];int res[505][505];int vis[505][505];int sx, sy, px, py;int dx[4] = &#123;1, 0, -1, 0&#125;;int dy[4] = &#123;0, 1, 0, -1&#125;;int n, m;void dfs(int x, int y) &#123; for(int i = 0; i &lt; 4; i++) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if(nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= m &amp;&amp; vis[nx][ny] == 0 &amp;&amp; Map[nx][ny] == '1') &#123; vis[nx][ny] = 1; res[nx][ny] = 1; Map[nx][ny] = '2'; if(nx &gt; px) &#123; px = nx; &#125; if(ny &gt; py) &#123; py = ny; &#125; if(nx &lt; sx) &#123; sx = nx; &#125; if(ny &lt; sy) &#123; sy = ny; &#125; dfs(nx, ny); vis[nx][ny] = 0; &#125; &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; getchar(); for(int j = 1; j &lt;= m; j++) &#123; scanf(\"%c\", &amp;Map[i][j]); &#125; &#125; for(int j = 1; j &lt;= m; j++) &#123; for(int i = 1; i &lt;= n; i++) &#123; if(Map[i][j] == '1') &#123; px = i; py = j; sx = i; sy = j; Map[i][j] = '2'; res[i][j] = 1; dfs(i, j); printf(\"%d %d\\n\", (px - sx + 1), (py - sy + 1)); for(int k = sx; k &lt;= px; k++) &#123; for(int p = sy; p &lt;= py; p++) &#123; printf(\"%d\", res[k][p]); if(res[k][p]) res[k][p] = 0; if(vis[k][p]) vis[k][p] = 0; &#125; printf(\"\\n\"); &#125; &#125; &#125; &#125; return 0;&#125; C++&nbsp;&nbsp;&nbsp;&nbsp;bfs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;char Map[505][505];int res[505][505];int vis[505][505];int sx, sy, px, py;int dx[4] = &#123;1, 0, -1, 0&#125;;int dy[4] = &#123;0, 1, 0, -1&#125;;int n, m;struct Point &#123; int x, y;&#125;;void bfs(int x, int y) &#123; queue&lt;Point&gt; queue; Point now; now.x = x; now.y = y; queue.push(now); vis[x][y] = 1; while(!queue.empty()) &#123; now = queue.front(); queue.pop(); for(int i = 0; i &lt; 4; i++) &#123; Point next; next.x = now.x + dx[i]; next.y = now.y + dy[i]; if(next.x &gt; 0 &amp;&amp; next.x &lt;= n &amp;&amp; next.y &gt; 0 &amp;&amp; next.y &lt;= m &amp;&amp; vis[next.x][next.y] == 0 &amp;&amp; Map[next.x][next.y] == '1') &#123; vis[next.x][next.y] = 1; res[next.x][next.y] = 1; if(next.x &gt; px) px = next.x; if(next.y &gt; py) py = next.y; if(next.x &lt; sx) sx = next.x; if(next.y &lt; sy) sy = next.y; Map[next.x][next.y] = '2'; queue.push(next); &#125; &#125; &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; getchar(); for(int j = 1; j &lt;= m; j++) &#123; scanf(\"%c\", &amp;Map[i][j]); &#125; &#125; for(int j = 1; j &lt;= m; j++) &#123; for(int i = 1; i &lt;= n; i++) &#123; if(Map[i][j] == '1') &#123; px = i; py = j; sx = i; sy = j; vis[i][j] = '2'; res[i][j] = 1; bfs(i, j); printf(\"%d %d\\n\", (px - sx + 1), (py - sy + 1)); for(int k = sx; k &lt;= px; k++) &#123; for(int p = sy; p &lt;= py; p++) &#123; printf(\"%d\", res[k][p]); if(res[k][p]) res[k][p] = 0; if(vis[k][p]) vis[k][p] = 0; &#125; printf(\"\\n\"); &#125; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"hihoCoder","slug":"hihoCoder","permalink":"http://yoursite.com/tags/hihoCoder/"}]},{"title":"HelloWorld,Markdown","slug":"HelloWord,Markdown","date":"2018-12-12T08:09:45.303Z","updated":"2018-12-17T11:04:39.261Z","comments":true,"path":"2018/12/12/HelloWord,Markdown/","link":"","permalink":"http://yoursite.com/2018/12/12/HelloWord,Markdown/","excerpt":"","text":"HelloWorldMarkdown语法里，#加空格再加标题代表是一个一级标题，一级标题的字体最大 Markdown两个#号加空格加标题是一个二级标题 其它语法两个星号+文字+两个星号：对文字进行加粗一个星号加文字加一个星号：对文字进行倾斜 右移符号代表这是单独一行的注释 短破折号加空格加文字代表列表分点(实心圆点) 数字加一个点加空格也代表列表分点(数字) 一个短破折加空格加中括号代表这是一个复选框 中括号里面一个空格代表未被选中，一个x表示选中 对于以上四种格式，下移一行会自动沿用其格式两个波浪线加文字加两个波浪线代表这是一个已过期不可用的文字 反单引号加文字加反引号：对指定文字加这种效果 一行的最前面空四个空格：对整行加这种效果 为文字添加链接：中括号里面加文字，中括号后面紧接着括号，括号里面填写链接地址 或符号用于制表 头行自动加粗 中间一行短破折号为分隔 表格里面的内容需要换行时用换行，且同一行的语句不能无故Enter换行，否则会识别成跳到下一行的单元格。表格内容通过加:来修改对齐方式,:–(左对齐),–:(右对齐), :–:(默认对齐方式,居中对齐) 在这写了几篇博客发现，这里的空格我都不会用了，不管多少个空格都只会识别成一个空格，这就很烦了。(嫌弃一个空格的间距太小) KaTeX可以使用 KaTeX 渲染LaTeX数学表达式：使用一个美元号加数学公式加一个美元号来渲染数学公式，两个美元符号加数学公式加两个美元符号会使数学公式自动居中正常形式：T(n)数学公式：$T(n)$数学公式里的符号： \\quad：空格 \\forall：$\\forall$ (任意) \\in：$\\in$ (属于) \\int：$\\int$ (积分) \\int_0：$\\int_0$ (从0开始积分) \\infty：$\\infty$ (无穷大) \\int_0^1：$\\int_0^1$ (从0到1范围内积分) a^{b}：$a^{b}$ (a的b次方) 更多数学表达式请移步此处 流程图UML时序图感觉太难画了，看到就头大，还是跳过好了，需要时再来瞅瞅。(逃先写这两行表示要画流程图： mermaid graph LR 画线，由矩形A到圆B：A[编号A] - - Link text –&gt; B((编号B))12graph LRA[编号A] -- Link text --&gt; B((编号B)) 如上，[]表示矩形，(())表示圆，()表示圆角矩形，{}表示菱形。这些符号里面填写的是框内的文字。- -&gt;为直接到，- -文字- -&gt;给路线添加文字 每行写一条线，结合起来就是个图：12345graph LRA[编号A] -- Link text --&gt; B((编号B))A --&gt; C(编号C)B --&gt; D&#123;编号D&#125;C --&gt; D 结束一个图，最后一行： ` 新手教程结束。这么原生的标记语言还真是不简单，忽然觉得写CSDN博客能直接用最上方工具栏编写是多么幸福的事啊，哇咔咔后续博客可能还是会在CSDN写的多点，毕竟那里真的方便多了(逃附上我的CSDN博客,欢迎点击此处关注我,嘿嘿","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]},{"title":"第九届蓝桥杯C++ B组国赛第四题","slug":"C++ B No4","date":"2018-12-12T04:20:25.818Z","updated":"2018-12-17T11:02:46.775Z","comments":true,"path":"2018/12/12/C++ B No4/","link":"","permalink":"http://yoursite.com/2018/12/12/C++ B No4/","excerpt":"","text":"标题：调手表小明买了块高端大气上档次的电子手表，他正准备调时间呢。在 M78 星云，时间的计量单位和地球上不同，M78 星云的一个小时有 n 分钟。大家都知道，手表只有一个按钮可以把当前的数加一。在调分钟的时候，如果当前显示的数是 0 ，那么按一下按钮就会变成 1，再按一次变成 2 。如果当前的数是 n - 1，按一次后会变成 0 。作为强迫症患者，小明一定要把手表的时间调对。如果手表上的时间比当前时间多1，则要按 n - 1 次加一按钮才能调回正确时间。小明想，如果手表可以再添加一个按钮，表示把当前的数加 k 该多好啊……他想知道，如果有了这个 +k 按钮，按照最优策略按键，从任意一个分钟数调到另外任意一个分钟数最多要按多少次。注意，按 +k 按钮时，如果加k后数字超过n-1,则会对n取模。比如，n=10, k=6 的时候，假设当前时间是0，连按2次 +k 按钮，则调为2。 「输入格式」一行两个整数 n, k ，意义如题。 「输出格式」一行一个整数表示：按照最优策略按键，从一个时间调到另一个时间最多要按多少次。 「样例输入」5 3 「样例输出」2 「样例解释」如果时间正确则按0次。否则要按的次数和操作系列之间的关系如下：1：+12：+1, +13：+34：+3, +1 「数据范围」对于 30% 的数据 0 &lt; k &lt; n &lt;= 5对于 60% 的数据 0 &lt; k &lt; n &lt;= 100对于 100% 的数据 0 &lt; k &lt; n &lt;= 100000 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 思路看到网上很多用广搜做的，本人在赛时考虑的是模拟，个人觉得我这种方法也可以。题目要求的是从任意一个分钟数调到另外任意一个分钟数最多要按的次数，其实也就是求从某一分钟开始能遍历完所有别的分钟最少要按的次数，最多是需要n次的(每次都只按+1)。又因为这个表是环形的，n-1按+1后会变成0，因此可以设定任意一个起点，题目转换成从单一固定起点开始能遍历完所有别的分钟最少要按的次数。所以模拟每一次按表，我设置一个a数组记录某分钟是否被调到过，假设从0开始调，每次调表时都新定义一个set容器，然后遍历每一个分钟数，在被调到过的分钟数的基础上继续调一次并丢进set里。每次都要计数目前有多少个分钟数被调过，所有的分钟数都被调过则可以提前跳出次数循环，输出此时的次数即可。 我的代码123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;set&gt;using namespace std;int main() &#123; int n, k, i, sum = 1, a[100005], t; memset(a, 0, sizeof(a)); a[0] = 1;//起点 scanf(\"%d%d\", &amp;n, &amp;k); for(i = 1; i &lt;= n; i++) &#123; set&lt;int&gt; s; for(int j = 0; j &lt; n; j++) &#123; if(a[j]) &#123; t = j + 1; if(t &gt;= n) t = (t - n) % n; if(!a[t]) s.insert(t); t = j + k; if(t &gt;= n) t = (t - n) % n; if(!a[t]) s.insert(t); &#125; &#125; sum += s.size(); set&lt;int&gt;::iterator iter; for(iter = s.begin(); iter != s.end(); iter++) a[*iter] = 1; if(sum &gt;= n) break; &#125; printf(\"%d\\n\", i); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/tags/蓝桥杯/"}]}]}